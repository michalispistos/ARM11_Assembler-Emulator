\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}

\title{ARM Final Report}
\author{Sarveen Santhiramohan \\ Anthony Lee\\ Ezra Sitorus\\ Michalis Pistos}
\date{May/June 2020}

\begin{document}
\maketitle

\subsection*{1. Structure and implementation of assembler}

Our assembler consists of a main function in assemble.c which calls a series of functions which
are defined in the library assemble_utils. 

To implement the assembler, we decided on using the two pass method with a map as the symbol table.
Initially, when our map was only used to store label addresses and opcodes for instructions, each
key (word) was mapped to an integer value (code) corresponding to the address or opcode of the key.
However, at a later stage, we decided on adding another field for a function pointer so that instructions
of different types could be mapped to the respective assemble functions in the second pass. 
\par
In the first pass, we create the symbol table and add the addresses of each label that we encounter.
Before executing the second pass, we add every instruction that we support along with their
respective opcodes and functions to the symbol table. We also add a pointer to the 'end' of the program
which is used in single data transfer instructions where the expression is required to be stored at the 
end of the assembly file if it is too large. The first pass is done in the function create_symbol_table.
\par
We then proceed to the second pass, in which we directly translate each assembly instruction into a 32 bit binary code.
This is done by looking at the first word of each line which determines its instruction type by looking up through the 
lookup table. We pass the entire line then to the appropriate function and outputs a 32 bit instruction that gets written 
into the ouput file. Labels are ignored and when a single data transfer requires storing a large number we can use the end value 
to find the last address of the instructions and place the new number there. This is done by adding a new element
to the map with no string and the large number required as the integer code. If multiple numbers are added,
these entries are added in a queue like manner to the end of the map which can be added once we finish 
translating the original assembly code.
\par
In both the first pass and the second pass, we used the tokenizer function to parse the assembly files. The tokenizer
created an array of character pointers (strings) from one line of assembly. For example "add r1 #2" would be split
into ["add","r1","#2"]. In the second pass, we used the get function of our map on the first element of the array
returned by tokenizer to retrieve a function pointer so that we could pass the tokens to that function. We decided
to do it this way with seperate assemble functions for each data type for two reasons. Firstly, this way everyone
could work on a function each without interfering. Secondly, we thought that making it seperate would make our
code more readable and easier to modifiy in the event we needed to make changes to it in the future. The results from
the assemble_functions were then written to an array which then is written to a binary file by the function write_file.


\\ \\
\bigskip
\subsection*{2. Description of extension}
\bigskip
\subsection*{3. Design and challenges of extension}
\bigskip
\subsection*{4. Testing of implementation}
We mainly just used the provided test-suite for our testing as it was already quite extensive. 
\bigskip
\subsection*{5. Group reflection}

Anthony:

Ezra: Team communication has definitely improved from the assembler section. As before, the use of VSCode LiveShare allowed multiple
people to work on the same problem at the same time - effectively increasing the productivity of our group. This was done with the use
of voice calls and text chat in the live coding sessions. Furthermore, we decided to do better planning before starting out our project. 
The plan described the map data structure we would use as well as the general functioning of the assembler. We discussed various parts, such
as whether to do a single-pass or two-pass method and how the symbol table would be implemented and used, in order to minimise unnecessary time
discussing these things later as it would break up the flow of productivity. To add to this, we frequently tested small chunks of the program
instead of leaving it all up to the very end. As a result, I would push to use a live sharing option for future
group projects as well as a reasonable amount of time dedicated to planning the project as opposed to jumping straight in. However, our planning
did not anticipate minute inconveniences in the project. Since we did the project sequentially, we often discovered problems or issues that affects
some already completed section much later on. I think this problem could have been resolved if we split up and did sections in a non-linear fashion
so that if such an issue appeared, this could be discussed by the group and be resolved quicker.

Michalis: As I've said in the previous report I believe that our team worked incredibly well together. The fact that 
we were using VSCode liveShare mode allowed us to help each other and learn a lot of things at the same time. 
Moreover, I believe that in PartII we improved our communication compared to PartI. This had as a result work being
done much quicker since we didn't have people working on the same tasks at the same time. Instead, 
we decided to split all the tasks at the start so we can work independently and save a lot of time from repeated code.
Finally, this group project was beneficial for me since it was my first major group project that took a couple of weeks of time 
and taught me a lot of things about how a team should operate. The next time that I am requested to work with a group I will 
definitely follow some of the tactics that we implemented on this project.First of all, I will make sure that we split the tasks 
so we work more efficiently, but also give the required importance on communication. Since what I've seen from this project is that 
communicating with each other constantly and informing every team member for each major change you've made is crucial in order to keep
them updated and save everyone from unnecessary work.

Sarveen: I think that our teamwork has improved further compared to the emulator phase of the project. I believe that
by using our approach of live-coding at the same time as opposed to coding seperately and merging has significantly
decreased the amount of time it took to complete the project. This is due to the lack of any serious conflicts we could
have had were we to use git, and also because we were able to communicate in real time. For instance, this allowed us 
to clarify parts of the specification and continue coding without delay as the live chat and voice chat is embedded
into the platform. However, there is still some room for improvement. The most important thing that I think we could 
improve on is to set miniture goals that we should aim to complete in a given time. I think this will be beneficial 
as it will allow us to have more structure in the way we complete the project and we may be able to work faster if we
have small achievable deadlines. Another important strategy that we should consider is to get some team members to work
on later parts of the project instead of doing it sequentially from the beginning. The reason for this is that we had 
to rewrite sections of our code to accomodate simpler functions in later parts of our code.  For example, we wrote the 
map first but then we had to modifiy it once we got to a section of single data transfer. 

\bigskip
\subsection*{6. Individual reflection}

Anthony:

Ezra: I think the hardest part of group work is starting out with new people. Since the 4 of us have never undertaken a 
large programming groupproject, and with the additional fact that none of us had programmed in C, it seemed like it would
be a very difficult task. Nevertheless, I think that our group worked very well together. I think one of my strengths was 
communication and getting the group to start working in the beginning. Another strengh I think I have is thinking algorithmically - 
I think I was quite helpful when other group members were asking how to implement or fix something. 

Michalis: Initially, when I learned about that group project I got pretty worried because I am a pretty shy person, which 
I thought would have a significant impact on my communication with the team. Moreover, I thought that I would have trouble 
expressing my own opinions and ideas. On the other side, I consider myself a very organized person which I thought would 
be a significant strength in a group project since I like putting tasks in order, focusing at one thing at a time and always 
having a plan about what I am currently doing and what I want to do and achieve every day. However, after we started the 
project thankfully my worries didn't come true. Thanks to my team and our chemistry I felt really relaxed
from the start and I was always saying my opinion without thinking about it. On the other hand, one weakness
that I discovered through this project is that sometimes I am too confident on my ideas and I really want them to get implemented. 
However, I think that through this project  I learned to be more open to other ideas, understand when they are better than mine, 
and promote them instead. Finally, one strength that I've discovered is my persistence to make things look good and consistent which 
I believe is necessary in all group projects.

Sarveen: Prior to this project, I thought that it may be difficult to work in a group because of my lack of experience in teamwork. 
However, communication and also co-ordination were both much better than I anticipated. 
\end{document}